Some random notes regarding the dska.c dsp starters kit assemblerunofficial replacement I have created. This kinda assumes you have a TIDSP Starters' kit and you have tried to use their assembler.Features this assembler has that the standard dska.exe that comes freewith the DSK did not have: simple arithmetic expressions (+-*/ and ()s) nested include files nested .if/.else/.endif free source code Linux compatibility (actually general portability but I haven't testedit that much to make that claim) second pass listing showing actual generated code offsetsFeatures this assembler lacks that the standard dska.exe had:The command line option to define symbols.To use this assembler, you will probably need to compile it yourselfsince I only give out source code. You have to link with the mathlibrary probably (-lm).I compile it regularly on Linux with GCC and occasionally on MS-DOSwith Borland's Turbo-C 2.0.To run the assembler the command line is:  dska source.asm binout.dsk listout.lstThe arguments are file names.  source.asm is your input file.  binout.dsk is the output binary in .dsk format just like the TIassembler  listout.lst is the output listing file much like the TI assembler butI think it is betterIf you do not want one of the output files then use /dev/null (or NUL:on MS-DOS).The .dsk binary file format is pretty stupid but we have to use it to beable to cooperate with the debugger and stuff.You should be able to use an expression combining numbers and symbolsanywhere that you could use a number or a symbol before. The obviousexception is the dumb expressions as labels that TI tries to call afeature in their assembler. You can only have plain symbol names in thelabel positions of lines.The colons (":") on labels are optional. Labels and only labels startin column one. Comments can also start in column one. Either a ";" or a"*" in column one makes the whole line into a comment. "*" not incolumn one will generally just be an error if it doen't make sense as amultiplication. Anything else must be preceded by a space or a tab.Labels must be separated from the operation field by a space or a tab.The nasty restrictions they claim for the conditional assemblyexpression is of course totally relaxed.I think you could use an external macro processor such as m4 but itwould mean the line numbers wouldn't mean much any more. Perhaps somedaythe assembler could recognize embeded #line operations.One place you cannot (yet) use expressions is the floating point valuesfor the .qxx, .lqxx, .float, .double, .bfloat, and .efloat directives.Ordinary labels cannot be redefined but labels on .set directives can beredefined at will.Forward references are generally OK in the instruction operands anddata lists but if you try hard enough you can get things confusedbetween the values found for pass 1 and pass 2. The assembler mightmissleadingly claim you are trying to redefine labels in pass 2.The listings show only the first two words of generated object code foreach line. Do not be concerned if you want more than two words of datagenerated for a .word, .byte, .string, or one of the floating pointformats that generates more than two words. The .dsk file will be fineeven though the listing only shows the first two words. You can see thedata in the .dsk file itself or you can examine the memory with thedebugger. Perhaps I will fix this someday if I can figure out a niceway to do it.A lot of the error messages are repeated the same on both passes.Error messages in the listing file will generally PRECEDE the line theyrefer to."$ .set nnnn" is allowed but doesn't accomplish anything. The symbol"$" is reset to the current assmbly address for every line of theassembly. Using "$" as a label will produce lots of wierd errormessages.Constants have many epresentations. hex can be $123 or 123h or 0x123.Note that hex numbers must start with a digit. Add a leading zero ifyou want. Octal can be 0123 or any number with a leading 0(zero)without a trailing type (or leading 0x). Binary (base 2) can be 10101bor 010101b or whatever. Decimal base 10 is whetever is left over. Allconstant numbers must start with a digit 0 thru 9 or a $ (dollar) or a+ or -. This is probably ambiguous and you will get weird results ifyou mess it up. The assembler probably won't even notice some of theseerrors.I make no effort to pass judgment on the severity of conditionsdetected. Error messages are not classified into warnings and fatals.Lines skipped with .if can produce error messages while trying todecode opcode fields looking for .endif. .else or nested .ifs. Thisjust means you should only use conditional assembly for actual code. Toskip over comment blocks or other lines which should never be assembleduse regular comment lines, not conditional assembly.If you look at the structure of the assembler itself, you will find itis pretty straight forward. Pass_1 and pass_2 contain mainly a giantswitch statement each based on the statement we are working on. Thereis lots of code duplicated which might better have been in commonfunctions. This design resulted from seat-of-the-pants design whilecoding and edit mark block and copy, not from any deep conviction thatit is right. The look up of the operation and the symbols are ultrasimple linear searching. Hashing or sorting seemed like more troublethan they were worth. Tables have hard (but I think generous) limitsthat require editing the source and recompiling to change.Lloyd Millerlloyd@lfmcal.cuc.ab.ca1994 May 23 .. June 21